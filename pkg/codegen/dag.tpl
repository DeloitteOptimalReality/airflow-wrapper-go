############################################# WARNING #############################################
# This file is automatically generated. Please do not edit it manually as it could break the DAG. #
###################################################################################################

import json
import os
from datetime import datetime, timedelta
from airflow.models.dag import DAG

from airflow.models import Connection
from airflow.operators.python import PythonOperator
from airflow.utils.db import provide_session

# custom OR operator
from custom_operators.or_http_operator import ORHttpOperator

# required so HTTP operator does not crash Python
os.environ["no_proxy"] = "*"
default_args = {
    'owner': 'airflow',
    'depends_on_past': {{.DagDef.DefaultArgs.DependsOnPast | BoolTitle}},
    'email': ['{{.DagDef.DefaultArgs.Email}}'],
    'email_on_failure': False,
    'email_on_retry': False,
    'retries': {{.DagDef.DefaultArgs.Retries}},
    'retry_delay': timedelta(minutes={{.DagDef.DefaultArgs.RetryDelay}}),
}

dag = DAG(
    '{{.DagDef.ID}}',
    default_args=default_args,
    description='{{.DagDef.Description}}',
    schedule_interval=None,
    start_date=None, # this is None by default but should be FE driven. Something like: datetime({{.DagDef.StartDate.Year}}, {{.DagDef.StartDate.Month}}, {{.DagDef.StartDate.Day}}),
    catchup=False,
    tags=[{{range $index, $tag := .DagDef.Tags}}{{if $index}}, {{end}}'{{$tag}}'{{end}}],
)

# ##################### HELPER FUNCTIONS ##########################

@provide_session
def create_http_connection(conn, session=None):
    connection = session.query(Connection).filter(
        Connection.conn_id == conn['ConnectionID']).first()

    if connection:
        connection.conn_id = conn['ConnectionID']
        connection.conn_type = 'http'
        connection.host = conn['Host']
        connection.port = conn['Port']
        session.commit()
    else:
        # Create a new connection if it doesn't exist
        connection = Connection(
            conn_id=conn['ConnectionID'],
            conn_type='http',
            host=conn['Host'],
            port=conn['Port']
        )
        session.add(connection)
        session.commit()
    return f'Connection {conn["ConnectionID"]} successful!'

# ##################### ESTABLISH DB/REDIS CONNECTIONS #######################
{{range $conn := .Connections}}
{{ transformTaskID $conn.ConnectionID }} = PythonOperator(
    task_id='{{$conn.ConnectionID}}',
    python_callable=create_http_connection,
    op_args=[{{toMap $conn | mapToPythonDict}}],
    dag=dag,
){{ end }}

# ##################### REFERENCE MAPPING ##########################

# Dictionary to map transformed task IDs to original task IDs
task_id_map = {
    {{- range $original, $transformed := originalTaskIDMap }}
    "{{ $transformed }}": "{{ $original }}",
    {{- end }}
}

# ##################### PROCESSING OPERATORS ##########################
{{range .Tasks}}
{{ transformTaskID .TaskID }}_data = {{mapToPythonDict .Data}}
{{ transformTaskID .TaskID }} = ORHttpOperator(
    name='{{.Name}}',
    task_id='{{.TaskID}}',
    allow_illegal_argument=True,
    method='POST',
    http_conn_id='{{.ConnectionId}}',
    endpoint='{{.Endpoint}}',
    data=json.dumps({{ transformTaskID .TaskID }}_data),
    headers={"Content-Type": "application/json"},
    log_response=True,
    dag=dag,
    use_cache=True,
    {{- if checkDeps .Upstream }}
    dependencies=[{{- range $dep := .Upstream}}"{{$dep}}",{{- end -}}]
    {{- end}}
){{ end }}

# ##################### DIRECTED ACYLIC GRAPH DEFINITION ##########################
{{range $conn := .Connections}}
{{- if checkDeps $conn.Downstream }}
{{- range $dep := $conn.Downstream}}
{{ transformTaskID $conn.ConnectionID }}.set_downstream({{ transformTaskID $dep }})
{{- end -}}
{{- end -}}
{{- end -}}

{{range .Tasks }}
{{if checkDeps .Downstream -}}
{{ $taskId := transformTaskID .TaskID -}}
{{range $dep := .Downstream -}}
{{$taskId}}.set_downstream({{ transformTaskID $dep }})
{{ end -}}
{{ end -}}
{{ end -}}